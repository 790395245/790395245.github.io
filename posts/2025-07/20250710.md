---
title: 写出优雅的Python（第二期：Python日志管理和报错捕获）
date: 2025-07-10
categories:
  - 技术分享
tags:
  - 团队协作
  - 代码规范
  - 写出优雅的Python
description: 写出优雅的Python
articleGPT: 本期“写出优雅的Python”聚焦于日志管理和异常处理，强调它们在问题定位、提升程序健壮性、数据追踪和团队协作中的关键作用。
top:
share: true
delete: false
cover: https://cdn.rz15.cn/uploads/2025/07/ca32b71bc28c8f446c8c382083516905.jpeg
---

# 写出优雅的Python （第二期：Python日志管理和报错捕获）

## 为什么要重视日志和异常处理？

- 🕵️‍♂️ **定位问题利器**：日志和异常信息是排查线上问题的第一手资料
- 🛡️ **提升健壮性**：合理捕获异常，防止程序崩溃
- 📈 **数据追踪**：记录关键业务流程，便于分析和优化
- 🤝 **团队协作**：统一日志格式，方便他人理解和接手

---

## 一、日志管理

### 1. 日志的基本概念

日志（Logging）是指在程序运行过程中，将关键信息（如错误、警告、调试信息等）记录到文件、终端或远程服务器，便于后续分析和追踪。

### 2. Python标准库 logging

Python内置 logging 模块，功能强大且灵活，推荐作为首选。

#### 基本用法

```python
import logging

# 默认情况下，日志会输出到终端（标准输出，通常是控制台）
logging.basicConfig(level=logging.INFO)
logging.info("程序启动")
logging.warning("警告信息")
logging.error("出错了")
```

#### 日志级别

| 级别（Level） | 数值（Numeric Value） | 描述 |
|---------------|----------------------|------|
| DEBUG         | 10                   | 最详细的日志信息，通常仅在诊断问题时使用。包含了程序运行的详细步骤和变量值等。 |
| INFO          | 20                   | 确认事情按预期工作。用于记录程序正常运行过程中的一些关键信息，例如服务的启动、关闭，或一个重要任务的完成。 |
| WARNING       | 30                   | 表明发生了一些意外情况，或者预示着将来可能会出现问题，但程序本身仍在正常工作。例如，使用了已废弃的API，或者磁盘空间不足。 |
| ERROR         | 40                   | 由于一个更严重的问题，程序中的某些功能已经无法正常执行。例如，一个外部API调用失败，导致部分功能无法使用。 |
| CRITICAL      | 50                   | 严重的错误，表明程序本身可能无法继续运行。这通常会导致应用程序的崩溃或退出。 |

有效使用日志级别的关键在于根据不同的运行环境设置合适的日志级别：

  * **开发环境 (Development):** 通常将日志级别设置为`DEBUG`，以便获取最详细的程序运行信息，帮助快速定位和修复bug。
  * **测试/预发布环境 (Staging/Testing):** 可以设置为`INFO`或`DEBUG`，取决于测试的深度和对性能的需求。`INFO`级别可以帮助确认各项功能是否按预期流程执行。
  * **生产环境 (Production):** 强烈建议将日志级别设置为`INFO`或`WARNING`。
      * `INFO`级别可以提供关键的业务流程信息，便于追踪用户行为和系统状态。
      * `WARNING`级别则更为保守，只记录需要关注的异常情况，可以有效减少日志量，降低系统开销。
      * 绝对不应在生产环境中使用`DEBUG`级别，因为它会产生大量冗余信息，影响性能，甚至可能泄露敏感数据。


#### 自定义日志格式和输出位置

```python
import logging

logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(filename)s:%(lineno)d - %(message)s",
    filename="app.log",  # 输出到文件
    filemode="a"         # 追加模式
)
logging.info("日志记录到文件")

# 2024-06-01 10:23:45,123 [INFO] 第二期.py:12 - 日志记录到文件
```
**常见日志格式化变量说明：**

| 变量名            | 含义                         | 示例值                      |
|-------------------|------------------------------|-----------------------------|
| `%(asctime)s`     | 日志时间（自动格式化）        | 2024-06-01 10:23:45,123     |
| `%(levelname)s`   | 日志级别                     | INFO                        |
| `%(filename)s`    | 当前文件名                    | 第二期.py                   |
| `%(lineno)d`      | 日志语句所在代码行号           | 12                          |
| `%(message)s`     | 日志正文内容                   | 日志记录到文件              |
| `%(name)s`        | logger名称                    | __main__ 或模块名           |
| `%(process)d`     | 进程ID                        | 12345                       |
| `%(thread)d`      | 线程ID                        | 140735249666816             |
| `%(funcName)s`    | 调用日志的函数名               | my_function                 |


#### 多模块日志统一

建议在每个模块单独获取 logger：

```python
import logging

logger = logging.getLogger(__name__)

def foo():
    logger.info("模块内日志")
```

将 `__name__` 传递给 `getLogger()`，可以利用`logging`模块内置的**层级结构（Hierarchical Structure）**。`logging`模块会根据点分路径自动维护一个日志记录器（logger）的树状层级。

输出的日志会非常清晰，一眼就能看出每条日志来自哪个具体的模块和层级：

```
2025-07-09 18:15:00,123 - my_app.api.endpoints      - INFO     - API endpoint called.
2025-07-09 18:15:00,124 - my_app.db.connection      - INFO     - Establishing database connection...
```


#### 灵活且精细的日志级别控制

你可以为不同模块（或子系统）设置不同的日志级别，而无需修改模块内部的代码。这在调试时极为有用。

**场景**：假设你的应用在生产环境中运行，全局日志级别为`INFO`。现在，你发现数据库相关的操作出现问题，需要更详细的日志来排查，但又不希望被其他模块的`DEBUG`信息淹没。

你可以在应用的入口处进行如下配置：

```python
# main.py
import logging

# 全局默认级别设置为 INFO
logging.basicConfig(level=logging.INFO, format='%(name)s: %(message)s')

# 获取数据库相关的logger，并单独将其级别设置为 DEBUG
# 注意：这里是获取 'my_app.db' 这个父logger
db_logger = logging.getLogger('my_app.db')
db_logger.setLevel(logging.DEBUG)

# 省略运行代码
```

**结果**：

  * 其他模块中的 `DEBUG` 日志将**不会**显示，因为它继承了全局的 `INFO` 级别。
  * `my_app.db.connection` 模块中的 `DEBUG` 日志将**会**显示，因为它属于 `my_app.db` 这个层级，而该层级已被显式设置为 `DEBUG`。

这种能力使得你可以像用手术刀一样精确地开启或关闭特定子系统的详细日志，极大地提高了调试效率。

**并且**：

每个模块只负责获取并使用自己的logger，它完全不需要关心日志最终如何被处理——是输出到控制台、写入文件，还是发送到远程服务器。实现了模块化与解耦。


#### 日志轮转（自动分割日志文件）

```python
import logging
from logging.handlers import RotatingFileHandler

handler = RotatingFileHandler("app.log", maxBytes=1024*1024, backupCount=3)
logging.basicConfig(handlers=[handler], level=logging.INFO)
logging.info("支持日志轮转")
```

#### 使用DEBUG级别日志帮助调试

  * **捕捉“为什么”和“如何”：** Debug 日志应该解释**正在发生什么**、**为什么发生**（如果可能，例如“用户未授权，跳过操作”）以及**如何完成**。

  * **变量状态：** 在关键节点（如计算前后、函数进出时）记录重要变量的值，有助于追踪数据流。
```python
    def process_data(data):
        logging.debug(f"收到待处理数据: {data}")
        # ...
        transformed_data = data.upper()
        logging.debug(f"数据转换后: {transformed_data}")
        return transformed_data
```
  * **函数进入/退出：** 记录函数的进入和退出，便于可视化调用栈和执行流程。
```python
    def calculate_sum(a, b):
        logging.debug(f"进入 calculate_sum，a={a}, b={b}")
        result = a + b
        logging.debug(f"退出 calculate_sum，result={result}")
        return result
```
  * **条件逻辑：** 在条件语句中记录分支选择，尤其是在复杂的 `if/elif/else` 结构中。
```python
    if status == "active":
        logging.debug("用户状态为 active，继续操作。")
        # ...
    else:
        logging.debug(f"用户状态为 {status}，跳过操作。")
```
  * **循环迭代：** 在循环中记录当前迭代次数及相关变量，尤其适用于长时间或复杂循环。
```python
    for i, item in enumerate(items):
        logging.debug(f"正在处理第 {i} 项: {item}")
        # ...
```


## 二、异常捕获与处理

### 1. 为什么要捕获异常？

- 防止程序崩溃，提升用户体验
- 记录异常信息，便于排查
- 可自定义处理逻辑（如重试、降级）

### 2. 基本用法

```python
try:
    risky_operation()
except ValueError as e:
    print(f"值错误: {e}")
except Exception as e:
    print(f"未知异常: {e}")
else:
    print("操作成功，无异常发生")
finally:
    print("无论如何都会执行")
```

### 3. 日志与异常结合

推荐在 except 块中记录异常详细信息：

```python
import logging

try:
    1 / 0
except Exception as e:
    logging.exception("捕获到异常")  # 自动记录堆栈信息

# 捕获到异常
# Traceback (most recent call last):
#   File "<python-input-3>", line 2, in <module>
#     1 / 0
#     ~~^~~
# ZeroDivisionError: division by zero
```

### 4. Python内置异常类
在 Python 中，所有异常必须为一个派生自 BaseException 的类的实例。常见的内置异常包括：
| 异常类名称                      | 描述                          | 示例代码                                                                                              | 示例输出                                                                                                         |
| -------------------------- | --------------------------- | ------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------ |
| **BaseException**          | 所有内置异常的基类                   | -                                                                                                 | -                                                                                                            |
| **Exception**              | 所有非系统退出异常的基类                | -                                                                                                 | -                                                                                                            |
| **ArithmeticError**        | 算术运算相关的错误的基类                | -                                                                                                 | -                                                                                                            |
| **ZeroDivisionError**      | 除以零时抛出                      | `result = 10 / 0`                                                                                 | `ZeroDivisionError: division by zero`                                                                        |
| **OverflowError**          | 算术运算结果超出表示范围时抛出             | `import math; math.exp(1000)`                                                                     | `OverflowError: math range error`                                                                            |
| **IndexError**             | 索引超出范围时抛出                   | `my_list = [1, 2, 3]; print(my_list[5])`                                                          | `IndexError: list index out of range`                                                                        |
| **KeyError**               | 字典中不存在指定的键时抛出               | `my_dict = {'a': 1, 'b': 2}; print(my_dict['c'])`                                                 | `KeyError: 'c'`                                                                                              |
| **ValueError**             | 操作或函数接收到合法类型但值不合适的参数时抛出     | `int("abc")`                                                                                      | `ValueError: invalid literal for int() with base 10: 'abc'`                                                  |
| **TypeError**              | 操作或函数被应用于不支持的类型时抛出          | `"123" + 456`                                                                                     | `TypeError: can only concatenate str (not "int") to str`                                                     |
| **NameError**              | 尝试访问未定义的变量时抛出               | `print(undefined_variable)`                                                                       | `NameError: name 'undefined_variable' is not defined`                                                        |
| **AttributeError**         | 尝试访问对象的不存在的属性或方法时抛出         | `my_list = [1, 2, 3]; my_list.upper()`                                                            | `AttributeError: 'list' object has no attribute 'upper'`                                                     |
| **IOError**                | 输入/输出操作失败时抛出                | -                                                                                                 | -                                                                                                            |
| **FileNotFoundError**      | 尝试打开不存在的文件时抛出               | `open("nonexistent_file.txt", "r")`                                                               | `FileNotFoundError: [Errno 2] No such file or directory: 'nonexistent_file.txt'`                             |
| **SyntaxError**            | 代码语法错误时抛出                   | `print("Hello`                                                                                    | `SyntaxError: EOL while scanning string literal`                                                             |
| **IndentationError**       | 缩进错误时抛出                     | `def my_function(): print("Hello")`                                                               | `IndentationError: expected an indented block`                                                               |
| **RuntimeError**           | 运行时出现错误，但没有更具体的异常类时抛出       | `def recursive_function(): recursive_function(); recursive_function()`                            | `RecursionError: maximum recursion depth exceeded`                                                           |
| **MemoryError**            | 程序运行时内存不足时抛出                | `my_list = [0] * (10**10)`                                                                        | `MemoryError`                                                                                                |
| **KeyboardInterrupt**      | 用户中断程序运行（通常是通过按下 Ctrl+C）时抛出 | -                                                                                                 | -                                                                                                            |
| **SystemExit**             | 调用 `sys.exit()` 时抛出         | `import sys; sys.exit()`                                                                          | -                                                                                                            |
| **ImportError**            | 导入模块失败时抛出                   | `import nonexistent_module`                                                                       | `ModuleNotFoundError: No module named 'nonexistent_module'`                                                  |
| **ModuleNotFoundError**    | 模块未找到时抛出                    | `import nonexistent_module`                                                                       | `ModuleNotFoundError: No module named 'nonexistent_module'`                                                  |
| **AssertionError**         | `assert` 语句失败时抛出            | `assert 1 == 2, "Assertion failed"`                                                               | `AssertionError: Assertion failed`                                                                           |
| **EOFError**               | 输入文件或输入流到达文件末尾时抛出           | `input()`（在空输入流下）                                                                                 | `EOFError: EOF when reading a line`                                                                          |
| **UnicodeError**           | 与 Unicode 编码或解码相关的错误        | `"abc".encode("ascii", "strict")`                                                                 | `UnicodeEncodeError: 'ascii' codec can't encode character '\u03b1' in position 0: ordinal not in range(128)` |
| **OSError**                | 操作系统相关的错误                   | `import os; os.mkdir("existing_directory")`                                                       | `FileExistsError: [Errno 17] File exists: 'existing_directory'`                                              |
| **PermissionError**        | 没有权限执行操作时抛出                 | `open("protected_file.txt", "w")`（无权限）                                                            | `PermissionError: [Errno 13] Permission denied: 'protected_file.txt'`                                        |
| **IsADirectoryError**      | 尝试对目录执行文件操作时抛出              | `with open("existing_directory", "r") as file: content = file.read()`                             | `IsADirectoryError: [Errno 21] Is a directory: 'existing_directory'`                                         |
| **NotADirectoryError**     | 尝试对文件执行目录操作时抛出              | `import os; os.listdir("file.txt")`                                                               | `NotADirectoryError: [Errno 20] Not a directory: 'file.txt'`                                                 |
| **FileExistsError**        | 尝试创建已存在的文件或目录时抛出            | `open("existing_file.txt", "x")`                                                                  | `FileExistsError: [Errno 17] File exists: 'existing_file.txt'`                                               |
| **ConnectionError**        | 与网络连接相关的错误                  | `import requests; requests.get("http://nonexistentwebsite.com")`                                  | `ConnectionError`                                                                                            |
| **TimeoutError**           | 操作超时时抛出                     | `import requests; requests.get("http://example.com", timeout=0.001)`                              | `TimeoutError`                                                                                               |
| **InterruptedError**       | 系统调用被中断时抛出                  | -                                                                                                 | -                                                                                                            |
| **BrokenPipeError**        | 尝试写入已关闭的管道时抛出               | -                                                                                                 | -                                                                                                            |
| **ChildProcessError**      | 子进程相关操作失败时抛出                | -                                                                                                 | -                                                                                                            |
| **ProcessLookupError**     | 尝试访问不存在的进程时抛出               | -                                                                                                 | -                                                                                                            |
| **BlockingIOError**        | I/O 操作被阻塞时抛出                | -                                                                                                 | -                                                                                                            |
| **ConnectionAbortedError** | 连接被对方中断时抛出                  | -                                                                                                 | -                                                                                                            |
| **ConnectionRefusedError** | 连接请求被拒绝时抛出                  | -                                                                                                 | -                                                                                                            |
| **ConnectionResetError**   | 连接被对方重置时抛出                  | -                                                                                                 | -                                                                                                            |

### 5. 精准的捕获异常
异常处理是编写健壮、可靠代码的关键部分。正确的异常捕获实践不仅能防止程序崩溃，还能提供有用的调试信息，并允许程序优雅地从错误中恢复。

```python
import requests

try:
    response = requests.get("http://invalid-url-example-123.com", timeout=5)
    response.raise_for_status() # 如果请求失败，抛出HTTPError
except requests.exceptions.Timeout:
    print("请求超时，请检查网络连接或稍后重试。")
    # 可以选择重新尝试
except requests.exceptions.RequestException as e:
    print(f"请求发生错误：{e}")
    # 进行处理
except Exception as e:
    print(f"发生了一个意料之外的错误：{e}")
    # 记录日志，并重新抛出异常向上传播
    raise
```

### 6. 自定义异常类
自定义异常应该继承自 Exception 或其子类。
```python
# 通过自定义异常类，强制执行业务规则和约束
class SampleNameError(Exception):
    """样本名错误异常类"""
    def __init__(self, message="样本名不符合要求"):
        super().__init__(message)

def check_sample_name(name):
    if not name.isalnum():
        raise SampleNameError(f"样本名错误: '{name}' 只允许字母和数字。")

try:
    check_sample_name("样本#001")
except SampleNameError as e:
    print(f"捕获到样本名错误异常: {e}")

``` 

## 三、实战示例：图片保存报错时不中断分析流程

```python
import logging
from functools import wraps
from PIL import Image 

# 配置日志，将日志输出到控制台和文件
logging.basicConfig(
    level=logging.ERROR, # 只记录 ERROR 级别及以上的日志
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(), # 输出到控制台
        logging.FileHandler('analysis.log') # 输出到文件
    ]
)

# 装饰器函数，用于捕获异常并记录日志
def error_logger(func):
    """捕获异常并记录日志的装饰器"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        try:
            # 尝试执行被装饰的函数
            return func(*args, **kwargs)
        except Exception as e:
            # 捕获所有异常并记录错误日志
            error_msg = f"Error in {func.__name__}: {str(e)}"
            # exc_info=True 输出完整的异常堆栈信息
            logging.error(error_msg, exc_info=True)
            # 返回None而不中断程序
            return None
    return wrapper

# 装饰保存图片的函数
@error_logger
def save_image(image: Image.Image, filepath: str):
    # 正常保存操作...
    image.save(filepath)
    print(f"Image successfully saved to {file_path}")
    return True

# 分析流程
def analyze_workflow():
    # 模拟数据分析流程
    print("数据分析中...")

    # 假设检查样本名
    check_sample_name(name)

    # 假设有图片需要保存，并且会触发异常
    save_image(image, filepath)
    
    print("保存数据")
    print("其他分析流程...")
    return True

# 测试用例
if __name__ == "__main__":
    try:
        analyze_workflow()
    except SampleNameError as e:
        logging.error(f"捕获到样本名错误异常: {e}")
        raise

    print("样本名错误时会中断流程")
    print("图片保存报错时不会中断分析流程，但会将报错堆栈记录到日志文件中。")

```

---

## 参考资源

1. [官方 logging 文档](https://docs.python.org/zh-cn/3/library/logging.html)
2. [loguru 官方文档](https://loguru.readthedocs.io/en/stable/)
3. [Sentry Python SDK](https://docs.sentry.io/platforms/python/)
4. [Python异常处理最佳实践](https://realpython.com/python-exceptions/)
5. [Python内置异常](https://docs.python.org/zh-cn/3/library/exceptions.html)
---

**下期预告：Python 标准库和高级特性**
